Module3: Configuration - 37 Lessons
1. Define, build and modify container images 07:30
2. Practice test Docker Images
3. Commands and Arguments in Docker 07:25
4. Commands and Arguments in Kubernetes 02:40
5. A quick note on editing Pods and Deployments
6. Practice Test - Kubernetes - CKAD - Commands and Arguments
7. Solution: Commands and Arguments (Optional) 19:31
8. Environment Variables 01:08
9. ConfigMaps 05:12
10. Practice Test - Kubernetes - CKAD - ConfigMaps
11. Secrets 08:20
12. Solution: ConfigMaps (Optional) 08:43
13. A quick note about Secrets!
14. Practice Test - Kubernetes - CKAD - Secrets
15. Additional Resource
16. Solution: Secrets (Optional) 09:53
17. Demo: Encrypting Secret Data at Rest 18:47
18. Pre-requisite - Security in Docker 05:37
19. Security Contexts 01:57
20. Practice Test - Kubernetes - CKAD - Security Contexts
21. Solutions-Security Contexts 06:12
22. Resource Requirements 14:51
23.Practice Test - Kubernetes - CKAD - Resource Limits
24. Solutions-Resource Requirements 03:25
25. Service Account 14:34
26. Practice Test - Kubernetes - CKAD - Service Account
27. Solutions-Service Account 08:04
28. Stay Updated!
29. Taints and Tolerations 09:55
30. Practice Test - Taints and Toleration
31. Node Selectors Logging 03:20
32. Solution - Taints and Tolerations (Optional) 10:09
33. Node Affinity 07:08
34. Practice Test - Node Affinity
35. Solution - Node Affinity (Optional) 10:13
36. Taints & Tolerations vs Node Affinity
37. Certification Tips - Student Tips

Modual 4: Multi-Container Pods - 6 Lessons
1. Multi-Container Pods 04:34
2. Practice Tests - Kubernetes CKAD - Multi Container Pods
3. Solution - Multi-Container Pods (Optional) 15:09
4. Init Containers
5. PRACTICE TEST – INIT CONTAINERS
6. Solution – Init Containers (Optional) 07:21


Module3: Configuration - 37 Lessons
1. Define, build and modify container images 07:30 -> Ultimated Course!!!
Create my own image - Dockerfile name 'DOCKERFILE'
----------------------------------------------------
FROM Ubuntu

RUN apt-get update
RUN apt-get-install python

RUN pip install flask
RUN pip install flask-mysql

COPY . /opt/source-code

ENTRYPOINT FLASK_APP=/opt/source-code/app.py flask run
--------------------------------------------------

■ docker build DOCKERFILE -t phuongton/my-custom-app
■ docker push phuongton/my-custom-app -> DOCKER REGISTOR

2. Practice test Docker Images
$ docker images
REPOSITORY                      TAG       IMAGE ID       CREATED        SIZE
mysql                           latest    7ce93a845a8a   7 weeks ago    586MB
alpine                          latest    324bc02ae123   7 weeks ago    7.79MB
nginx                           latest    a72860cb95fd   2 months ago   188MB
nginx                           alpine    1ae23480369f   2 months ago   43.2MB
ubuntu                          latest    35a88802559d   3 months ago   78MB
redis                           latest    6c00f344e3ef   3 months ago   116MB
postgres                        latest    07a4ee949b9e   4 months ago   432MB
kodekloud/simple-webapp-mysql   latest    129dd9f67367   5 years ago    96.6MB
kodekloud/simple-webapp         latest    c6e3cd9aae36   5 years ago    84.8MB

$ cat webapp-color/Dockerfile 
FROM python:3.6

RUN pip install flask

COPY . /opt/

EXPOSE 8080

WORKDIR /opt

ENTRYPOINT ["python", "app.py"]

Move to the directory first by using the cd command and verify the path of the working directory from pwd command :-

$ cd /root/webapp-color/
$ pwd
/root/webapp-color
Now, run the docker build command within that directory :-

$ docker build -t webapp-color . 
NOTE: At the end of the command, we used the "." (dot) symbol which indicates for the current directory, so you need to run this command from within the directory that has the Dockerfile.

$docker build . -t webapp-color 

Run an instance of the image webapp-color and publish port 8080 on the container to 8282 on the host.

$docker run -p 8282:8080 webapp-color

$ docker run python:3.6 cat /etc/*release*
PRETTY_NAME="Debian GNU/Linux 11 (bullseye)"
NAME="Debian GNU/Linux"
VERSION_ID="11"
VERSION="11 (bullseye)"
VERSION_CODENAME=bullseye
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"

$ docker images
REPOSITORY                      TAG           IMAGE ID       CREATED         SIZE
webapp-color                    latest        b0185275e2d1   3 minutes ago   913MB
nginx                           latest        39286ab8a5e1   4 weeks ago     188MB
mysql                           latest        7ce93a845a8a   7 weeks ago     586MB

3. Commands and Arguments in Docker 07:25
4. Commands and Arguments in Kubernetes 02:40
5. A quick note on editing Pods and Deployments
-------------------------------------------------------------------------------------
Remember, you CANNOT edit specifications of an existing POD other than the below.

spec.containers[*].image
spec.initContainers[*].image
spec.activeDeadlineSeconds
spec.tolerations

For example, you cannot edit the environment variables, service accounts, and resource limits (all of which we will discuss later) of a running pod. But if you really want to, you have two options:

1. Run the kubectl edit pod command. This will open the pod specification in an editor (vi editor). Then, edit the required properties. When you try to save it, you will be denied. This is because you are attempting to edit a field on the pod that is not editable.
A copy of the file with your changes is saved in a temporary location, as shown above.
You can then delete the existing pod by running the command:
kubectl delete pod webapp
Then, create a new pod with your changes using the temporary file:
kubectl create -f /tmp/kubectl-edit-ccvrq.yaml

2. The second option is to extract the pod definition in YAML format to a file using the command
kubectl get pod webapp -o yaml > my-new-pod.yaml
Then, make the changes to the exported file using an editor (vi editor). Save the changes
vi my-new-pod.yaml
Then, delete the existing pod.
kubectl delete pod webapp
Then, create a new pod with the edited file.
kubectl create -f my-new-pod.yaml
Edit Deployments
With Deployments, you can easily edit any field/property of the POD template. Since the pod template is a child of the deployment specification, with every change, the deployment will automatically delete and create a new pod with the new changes. So, if you are asked to edit a property of a POD part of a deployment, you may do that simply by running the command.
kubectl edit deployment my-deployment
-------------------------------------------------------------------------------------
6. Practice Test - Kubernetes - CKAD - Commands and Arguments
Create a pod with the ubuntu image to run a container to sleep for 5000 seconds. Modify the file ubuntu-sleeper-2.yaml.
---
apiVersion: v1 
kind: Pod 
metadata:
  name: ubuntu-sleeper-2 
spec:
  containers:
  - name: ubuntu
    image: ubuntu
    command:
      - "sleep"
      - "5000"
-----------------------------------
Create a pod using the file named ubuntu-sleeper-3.yaml. There is something wrong with it. Try to fix it!


Note: Only make the necessary changes. Do not modify the name.
---
apiVersion: v1 
kind: Pod 
metadata:
  name: ubuntu-sleeper-3 
spec:
  containers:
  - name: ubuntu
    image: ubuntu
    command:
      - "sleep"
      - 1200
---------------------------------
controlplane ~/webapp-color ➜  ls
Dockerfile   Dockerfile2

controlplane ~/webapp-color ➜  cat Dockerfile
FROM python:3.6-alpine

RUN pip install flask

COPY . /opt/

EXPOSE 8080

WORKDIR /opt

ENTRYPOINT ["python", "app.py"]

controlplane ~/webapp-color ➜  

--------------------------------
Inspect the file Dockerfile2 given at /root/webapp-color directory. What command is run at container startup?
controlplane ~/webapp-color ➜  cat Dockerfile2 
FROM python:3.6-alpine

RUN pip install flask

COPY . /opt/

EXPOSE 8080

WORKDIR /opt

ENTRYPOINT ["python", "app.py"]

CMD ["--color", "red"]


"python app.py --color red" 
------------------------------------


---
apiVersion: v1 
kind: Pod 
metadata:
  name: ubuntu-sleeper-3 
spec:
  containers:
  - name: ubuntu
    image: ubuntu
    command:
      - "sleep"
      - "1200"
	  
---
apiVersion: v1 
kind: Pod 
metadata:
  name: webapp-green
  labels:
      name: webapp-green 
spec:
  containers:
  - name: simple-webapp
    image: kodekloud/webapp-color
    args: ["--color", "green"]
7. Solution: Commands and Arguments (Optional) 19:31
8. Environment Variables 01:08
9. ConfigMaps 05:12

	  
configMap
APP_COLOR: blue
APP_MODE: prod


imperative: kubectl create configmap app-config --from-literal=APP_COLOR=blue --from-literal=APP_MODE=prod
imperative: kubectl create configmap app-config --from-file=<PATH of file>


declarative: config-map.yaml
--
apiVersion: k1
kind: ConfigMaps
metadata:
  name: config-map
data:
  APP_COLOR: blue
  APP_MODE: prod

kubectl create -f  config-map.yaml

kubectl get configmaps
kubectl describe configmaps

containers:
  envFrom:
    -configMapRef
	  name: config-map
	  
or
Using on environment variables

 - env:
    - name: APP_COLOR
	  valuefrom: 
	    configMapRef
		  name: config-map
		  key: APP_COLOR
10. Practice Test - Kubernetes - CKAD - ConfigMaps


---
apiVersion: v1
kind: Pod
metadata:
  labels:
    name: webapp-color
  name: webapp-color
  namespace: default
spec:
  containers:
  - env:
    - name: APP_COLOR
      value: green
    image: kodekloud/webapp-color
    name: webapp-color
	
	
Run the command kubectl create configmap  webapp-config-map --from-literal=APP_COLOR=darkblue --from-literal=APP_OTHER=disregard
controlplane ~ ➜  kubectl create -f webapp-config-map.yaml 
configmap/webapp-config-map created

controlplane ~ ➜  cat webapp-config-map.yaml 
apiVersion: v1
kind: ConfigMap
metadata: 
  name: webapp-config-map
data:
  APP_COLOR: darkblue
  APP_OTHER: disregard

---
apiVersion: v1
kind: Pod
metadata:
  labels:
    name: webapp-color
  name: webapp-color
  namespace: default
spec:
  containers:
  - env:
    - name: APP_COLOR
      valueFrom:
       configMapKeyRef:
         name: webapp-config-map
         key: APP_COLOR
    image: kodekloud/webapp-color
    name: webapp-color
11. Secrets 08:20
controlplane ~ ✖ echo -n "sql01" | base64
c3FsMDE=

controlplane ~ ➜  echo -n "root" | base64
cm9vdA==

controlplane ~ ➜  echo -n "password123" | base64
cGFzc3dvcmQxMjM=

controlplane ~ ➜  vi sample.yaml 

controlplane ~ ➜  kubectl create -f sample.yaml 
secret/db-secret created

controlplane ~ ➜  cat sample.yaml 
apiVersion: v1
kind: Secret
metadata: 
  name: db-secret
data:
  DB_Host: c3FsMDE=
  DB_User: cm9vdA==
  DB_Password: cGFzc3dvcmQxMjM=



controlplane ~ ➜  kubectl create -f create_pod.yaml 
pod/webapp-pod created

controlplane ~ ➜  cat create_pod.yaml
apiVersion: v1
kind: Pod
metadata:
  labels:
    name: webapp-pod
  name: webapp-pod
spec:
  containers:
  - image: kodekloud/simple-webapp-mysql
    name: webapp
    envFrom:
      - secretRef:
          name: db-secret
  

12. Solution: ConfigMaps (Optional) 08:43
13. A quick note about Secrets!
Remember that secrets encode data in base64 format. Anyone with the base64 encoded secret can easily decode it. As such the secrets can be considered as not very safe.

The concept of safety of the Secrets is a bit confusing in Kubernetes. The Kubernetes documentation page and a lot of blogs out there refer to secrets as a “safer option” to store sensitive data. They are safer than storing in plain text as they reduce the risk of accidentally exposing passwords and other sensitive data. In my opinion, it’s not the secret itself that is safe, it is the practices around it.

Secrets are not encrypted, so it is not safer in that sense. However, some best practices around using secrets make it safer. As in best practices like:

Not checking in secret object definition files to source code repositories.
Enabling Encryption at Rest for Secrets so they are stored encrypted in ETCD.
Also, the way Kubernetes handles secrets. Such as:

A secret is only sent to a node if a pod on that node requires it.

Kubelet stores the secret into a tmpfs so that the secret is not written to disk storage.

Once the Pod that depends on the secret is deleted, kubelet will delete its local copy of the secret data as well.

Read about the protections and risks of using secrets here

Having said that, there are other better ways of handling sensitive data like passwords in Kubernetes, such as using tools like Helm Secrets, and HashiCorp Vault. I hope to give a lecture on these in the future.

14. Practice Test - Kubernetes - CKAD - Secrets
15. Additional Resource
Dive deep into the world of Kubernetes security with our comprehensive guide to Secret Store CSI Driver.
https://www.youtube.com/watch?v=MTnQW9MxnRI
16. Solution: Secrets (Optional) 09:53
17. Demo: Encrypting Secret Data at Rest 18:47
18. Pre-requisite - Security in Docker 05:37
19. Security Contexts 01:57
20. Practice Test - Kubernetes - CKAD - Security Contexts

kubectl exec ubuntu-sleeper -- whoami
------------------------------------------------------------------
Edit the pod ubuntu-sleeper to run the sleep process with user ID 1010.
Note: Only make the necessary changes. Do not modify the name or image of the pod.

kubectl delete po ubuntu-sleeper 
---
apiVersion: v1
kind: Pod
metadata:
  name: ubuntu-sleeper
  namespace: default
spec:
  securityContext:
    runAsUser: 1010
  containers:
  - command:
    - sleep
    - "4800"
    image: ubuntu
    name: ubuntu-sleeper
----------------------------------------------------
Update pod ubuntu-sleeper to run as Root user and with the SYS_TIME capability.


Note: Only make the necessary changes. Do not modify the name of the pod.
>>
---
apiVersion: v1
kind: Pod
metadata:
  name: ubuntu-sleeper
  namespace: default
spec:
  containers:
  - command:
    - sleep
    - "4800"
    image: ubuntu
    name: ubuntu-sleeper
    securityContext:
      capabilities:
        add: ["SYS_TIME"]
		

--------------------------------------------------------------------------------
controlplane ~ ➜  kubectl delete po ubuntu-sleeper --force
Warning: Immediate deletion does not wait for confirmation that the running resource has been terminated. The resource may continue to run on the cluster indefinitely.
pod "ubuntu-sleeper" force deleted

controlplane ~ ➜  vi new_ubuntu.yaml

controlplane ~ ➜  kubectl create -f new_ubuntu.yaml 
pod/ubuntu-sleeper created

controlplane ~ ➜  cat new_ubuntu.yaml
---
apiVersion: v1
kind: Pod
metadata:
  name: ubuntu-sleeper
  namespace: default
spec:
  containers:
  - command:
    - sleep
    - "4800"
    image: ubuntu
    name: ubuntu-sleeper
    securityContext:
      capabilities:
        add: ["SYS_TIME","NET_ADMIN"]

21. Solutions-Security Contexts 06:12
22. Resource Requirements 14:51
23.Practice Test - Kubernetes - CKAD - Resource Limits
24. Solutions-Resource Requirements 03:25
25. Service Account 14:34
26. Practice Test - Kubernetes - CKAD - Service Account
27. Solutions-Service Account 08:04
28. Stay Updated!
29. Taints and Tolerations 09:55
30. Practice Test - Taints and Toleration
31. Node Selectors Logging 03:20
32. Solution - Taints and Tolerations (Optional) 10:09
33. Node Affinity 07:08
34. Practice Test - Node Affinity
35. Solution - Node Affinity (Optional) 10:13
36. Taints & Tolerations vs Node Affinity
37. Certification Tips - Student Tips

Modual 4: Multi-Container Pods - 6 Lessons
1. Multi-Container Pods 04:34
2. Practice Tests - Kubernetes CKAD - Multi Container Pods
3. Solution - Multi-Container Pods (Optional) 15:09
4. Init Containers
5. PRACTICE TEST – INIT CONTAINERS
6. Solution – Init Containers (Optional) 07:21





